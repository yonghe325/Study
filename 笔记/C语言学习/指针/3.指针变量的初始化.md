# 1指针变量的声明 
![[野指针01.png]]

二者不能混用
当   \*pi = 100 时
a的值
![[野指针02.png]]
当  \*pf = 100.0 时
a的值
![[野指针03.png]]

当运用指针变量pi为a赋值时,\*pi 将会以==整形的形式==将值赋给a
当运用指针变量pf为a赋值时,\*pf 将会以==浮点数的形式==将值赋给a
其原因是整型与浮点型的变量在内存中的存储方式不同,规则不同
# 2野指针
概念：野指针就是指针指向的位置是不可知(随机的,不正确的,没有明确限制的)
## 成因
### 未初始化
```
int* p;
*p = 10;
```
一个局部变量不初始化,放的是随机值 : 0xccccccc
导致\*p非法访问内存,此时p就是野指针
### 指针越界访问
```
int arr[10] = {0};
int* pa = &arr;
//此时pa存放arr[0]的地址
*(pa+9) = 1;
*(pa+10) = 1;  
```
arr数组只有10个元素
\*(pa+10)访问第11个,导致指针越界访问
(pa+10)成为野指针
### 指针指向的空间释放
```
int* test()
{
	int a = 10;
	return &a;
}
int main()
{
	int* pa = test();
	*pa = 20;
	return 0 ;
}
```
变量a为test内局部变量,离开test销毁变量a,a的内存被系统回收
pa指向的a的空间被释放,pa指向的空间不明确,导致pa成为野指针
但是
```
int* test()
{
	int a = 10;
	return &a;
}
int main()
{
	int* pa = test();
	if (p3 != NULL)
	{
		printf("%d\n",*p);
	}
	return 0 ;
}
```
打印出10
原因是形参a地址被系统回收
但原来的值仍是 10 
## 如何避免野指针
+ 指针初始化
+ 指针越界
+ 指针指向空间避免是NULL,未知地址的初始化为==NULL== (0) 相对 野指针  比较安全
+ 避免返回局部变量地址
+ 指针使用之前检查有效性


```
int* p2 = NULL;
*p2 = 100;
```
NULL本质上是地址 0 
地址 0 不允许写入
导致报错
```
int* p3 = NULL;
if (p3 != NULL)
{
	*p3 = 100;
}
\\或
if (p3)
{
	*p3 = 100;
}
```
可以,但
```
int* test()
{
	int a = 10;
	return &a;
}
int main()
{
	int* pa = test();
	if (p3 != NULL)
	{
		printf("%d\n",*p);
	}
	return 0 ;
}
```
无效,拍
