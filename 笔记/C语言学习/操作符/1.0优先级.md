表达式求值的顺序一部分是由操作符的==优先级==和==结合性==决定。
	#优先级: 运算顺序
	#结合性: 优先级相同时,看结合性(结合方向)
# 优先级,结核性 
+ 逻辑与 && 
+ 逻辑或 | |
+ 三目操作符 ?:
+ 三者会控制执行顺序
![[优先级00.png]]
![[优先级01.png]]
![[优先级02.png]]
![[优先级03.png]]
![[优先级04.png]]
![[优先级05.png]]
![[优先级06.png]]
![[优先级07.png]]
![[优先级08.png]]
# 问题表达式

##  1.运算顺序问题
![[问题表达式01.png]]
有两种运算顺序
当多个变量相互不影响时,可以可以不规定运算顺序
但当多个变量相互影响时,必须规定唯一运算顺序
## 2.存储顺序问题
![[问题表达式02.png]]
表达式共有2个c
先执行--
后+
但不确定第2个c是--前存放入内存,还是--后放入内存
本质上还是多个变量相互影响

## 3.编译器问题 + 运算顺序问题 +存储顺序问题
![[问题表达式03.png]]
![[问题表达式04.png]]
规定唯一运算顺序,使各种编译器运算结果相同
## 运用反汇编查看运算顺序
![[反汇编01.png]]
mov指令:将 1 移至 内存指针\[rbp+4]地址
rbp是寄存器,存放的是地址
此时\[rbp+4]即为变量a的地址
![[反汇编02.png]]
==inc== 为 自增 1 指令
### 第一部分 : 第一个++a
+ \[rgp+4]的值 移入 寄存器 eax 中
+ 将 eax 自增 1 
+ 将 eax 的值 移至 \[rgp+4]
+ 此时\[rgp+4] = 2  
### 第二部分 : 第二个++a
+ \[rgp+4]的值 移入 寄存器 eax 中
+ 将 eax 自增 1 
+ 将 eax 的值 移至 \[rgp+4]
+ 此时\[rgp+4] = 3
### 第三部分 : 第三个++a
+ \[rgp+4]的值 移入 寄存器 eax 中
+ 将 eax 自增 1 
+ 将 eax 的值 移至 \[rgp+4]
+ 此时\[rgp+4] = 4
### 第四部分 : 第一个++a 与 第二个++a 相加
+  \[rgp+4]的值 移入 寄存器 eax 中
+  \[rgp+4]的值 移入 寄存器 ecx 中
+ eax 加入 ecx中
+ 将 ecx 的值移至 eax 
+ eax = 8
### 第五部分 : 第三个++a 与 (第一个++a 与 第二个++a 相加的和) 相加
+ 将 \[rgp+4] 值加入 eax 中
+ eax = 12
### 第六部分 : 赋值 b
+ 将 eax 的值赋给 地址\[rbp+24h]
此时 \[rbp+24h] 即为 b 的地址
b = 12 
### 编译器问题
不同编译器的汇编指令不同
导致上述运算顺序不同,b的值也就不同